#include <Game.h>
#include <Macros.h>



constexpr int PLAYER_MOVE_FORCE{2000};
constexpr int STARTING_OBSTACLE_COUNT{5};
constexpr float ZOOM_FACTOR{10};
constexpr float POWERUP_SPAWN_RATE{10};
constexpr float DOWN_DURATION{5};
constexpr float DOWN_FORCE{10000};
constexpr float DOUBLE_DURATION{10};
constexpr float SCORE_REFRESH_RATE{0.05};


uint8_t activePowerups;
enum class Powerup
{
	SHIELD = (1 << 0),
	DOUBLE = (1 << 1),
	DOWN = (1 << 2)
};
float powerupSpawnTimer = POWERUP_SPAWN_RATE;
float downDurationTimer = DOWN_DURATION;
float doubleDurationTimer = DOUBLE_DURATION;

float scoreRefreshTimer = SCORE_REFRESH_RATE;

Entity player;
Entity camera;
Entity background, background2;

Entity shieldHUD, doubleHUD, downHUD;

Entity scoreHUD;
float score = 0;

bool gameover = false;
Entity gameoverHUD, retryHUD;

void Game::Start()
{
	// Backgrounds
	{
		background = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE);
		tf(background).scale = {285 * 3, 446 * 3};
		tf(background).pos = {0,0};
		sp(background) = GetSprite("res\\sprites\\background.png");

		background2 = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE);
		tf(background2).scale = {285 * 3, 446 * 3};
		tf(background2).pos = {0,-tf(background).scale.y};
		sp(background2) = GetSprite("res\\sprites\\background.png");
	}
	
	// Camera
	{
		camera = CreateEntity(ComponentFlag::TRANSFORM);
	}

	// Player
	{
		player = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE | ComponentFlag::RIGIDBODY | ComponentFlag::BOX_COLLIDER);
		sp(player) = GetSprite("res\\sprites\\player.png");
		tf(player) = { {0,windowSize.y / 3}, {60, 90}};
		rb(player).drag = {1,0.1};
		rb(player).gravity = 1000;
		rb(player).mass = 1;
		bc(player).scale = tf(player).scale * 0.8;
	}

	// HUD
	{
		shieldHUD = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE);
		tf(shieldHUD).scale = Vector2<float>{96,85} *0.6;
		tf(shieldHUD).pos = {-windowSize.x / 2 + tf(shieldHUD).scale.x, windowSize.y / 2 - tf(shieldHUD).scale.y};
		sp(shieldHUD) = GetSprite("res\\sprites\\shield.png");
		SetType("HUD", shieldHUD);

		doubleHUD = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE);
		tf(doubleHUD).scale = tf(shieldHUD).scale;
		tf(doubleHUD).pos = {tf(shieldHUD).pos.x + tf(shieldHUD).scale.x, windowSize.y / 2 - tf(shieldHUD).scale.y};
		sp(doubleHUD) = GetSprite("res\\sprites\\2.png");
		SetType("HUD", doubleHUD);

		downHUD = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE);
		tf(downHUD).scale = tf(shieldHUD).scale;
		tf(downHUD).pos = {tf(doubleHUD).pos.x + tf(doubleHUD).scale.x, windowSize.y / 2 - tf(shieldHUD).scale.y};
		sp(downHUD) = GetSprite("res\\sprites\\down.png");
		SetType("HUD", downHUD);

		scoreHUD = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::TEXT);
		tf(scoreHUD).scale = {64, 64};
		tf(scoreHUD).pos = {windowSize.x / 2 - tf(scoreHUD).scale.x / 2, windowSize.y / 2 - tf(scoreHUD).scale.y / 2};
		txt(scoreHUD).font = GetFont("res\\fonts\\Roboto-Bold.ttf");
		txt(scoreHUD).layer = 1;
		txt(scoreHUD).color = {0, 0, 0};
		SetType("HUD", scoreHUD);

		gameoverHUD = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::TEXT);
		tf(gameoverHUD).scale = {0,0};
		txt(gameoverHUD).font = GetFont("res\\fonts\\Roboto-Bold.ttf");
		txt(gameoverHUD).layer = 1;
		txt(gameoverHUD).text = " ";
		SetType("HUD", gameoverHUD);

		retryHUD = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::TEXT);
		tf(retryHUD).scale = {0,0};
		txt(retryHUD).font = GetFont("res\\fonts\\Roboto-Bold.ttf");
		txt(retryHUD).text = " ";
		txt(retryHUD).layer = 1;
		SetType("HUD", retryHUD);
	}

	for (int i = 0; i < STARTING_OBSTACLE_COUNT; i++)
		SpawnObstacle();

	PlayAudio("res\\audio\\music\\music.wav", -1);
}

void Game::Update()
{
	// Gameover
	{
		if (gameover)
		{
			activePowerups = 0;

			std::vector<Entity> temp = Entities();
			for (Entity e : temp)
			{
				Type type = GetType(e);
				if (type != "HUD")
					DeleteEntity(e);
			}
				

			tf(gameoverHUD).pos = ScreenToWorldPos({0,100});
			tf(gameoverHUD).scale = {50.f * txt(gameoverHUD).text.size(), 100};
			txt(gameoverHUD).text = "GAME OVER!";

			tf(retryHUD).pos = ScreenToWorldPos({0,-100});
			tf(retryHUD).scale = {10.f * txt(retryHUD).text.size(), 20};
			txt(retryHUD).text = "Press Space to retry.";

			tf(scoreHUD).pos = ScreenToWorldPos({0,0});
			tf(scoreHUD).scale = {25.f * txt(scoreHUD).text.size(), 50};
			txt(scoreHUD).color = {255, 255, 255};
			txt(scoreHUD).text = "Score: " + std::to_string((int)score);

			if (input.GetKeyDown(SDL_SCANCODE_SPACE))
				Reset();

			return;
		}
	}

	// Score
	{
		if (activePowerups & (int)Powerup::DOUBLE)
			score += -0.8 * rb(player).vel.y * DeltaTime();
		else
			score += -0.4 * rb(player).vel.y * DeltaTime();

		if (scoreRefreshTimer <= 0)
		{
			txt(scoreHUD).text = std::to_string((int)score);
			scoreRefreshTimer = SCORE_REFRESH_RATE;
		}
		else
			scoreRefreshTimer -= DeltaTime();
	}

	// Camera
	{
		tf(camera).pos.y = tf(player).pos.y - windowSize.y / 4;
		Camera(camera);

		
		if (input.GetKey(SDL_SCANCODE_P))
			tf(camera).scale += ZOOM_FACTOR * DeltaTime() * tf(camera).scale;
		if (input.GetKey(SDL_SCANCODE_L))
			tf(camera).scale -= ZOOM_FACTOR * DeltaTime() * tf(camera).scale;
		if (input.GetKey(SDL_SCANCODE_R))
			tf(camera).scale = {1,1};
		
	}

	// Backgrounds
	{
		if (tf(player).pos.y < tf(background).pos.y - tf(background).scale.y * 2 / 3)
		{
			tf(background).pos.y = tf(background2).pos.y - tf(background2).scale.y;
			std::swap(background, background2);
		}
	}

	// Player
	{
		// Input
		{
			if (input.GetKey(SDL_SCANCODE_A))
				rb(player).AddForce({-PLAYER_MOVE_FORCE,0});
			if (input.GetKey(SDL_SCANCODE_D))
				rb(player).AddForce({PLAYER_MOVE_FORCE,0});
			if (input.GetKey(SDL_SCANCODE_W))
				rb(player).AddForce({0,PLAYER_MOVE_FORCE / 4});
			if (input.GetKey(SDL_SCANCODE_S))
				rb(player).AddForce({0,-PLAYER_MOVE_FORCE / 4});
		}
		
		// Collision
		{
			std::vector<Entity> cols = GetCollisions(player);
			for (Entity col : cols)
			{
				Type type = GetType(col);
				if (type == "Obstacle")
				{
					DeleteEntity(col);
					if ((activePowerups & (int)Powerup::SHIELD) && !(activePowerups & (int)Powerup::DOWN))
						activePowerups -= (int)Powerup::SHIELD;
					else if ((activePowerups & (int)Powerup::DOWN) == false)
						gameover = true;
				}
				else if (type == "Shield")
				{
					activePowerups |= (int)Powerup::SHIELD;
					DeleteEntity(col);
				}
				else if (type == "Double")
				{
					activePowerups |= (int)Powerup::DOUBLE;
					doubleDurationTimer = DOUBLE_DURATION;
					DeleteEntity(col);
				}
				else if (type == "Down")
				{
					activePowerups |= (int)Powerup::DOWN;
					downDurationTimer = DOWN_DURATION;
					DeleteEntity(col);
				}
			}


			BoundingBox pBox = tf(player);
			float dampFactor = 1;
			if (pBox.right > windowSize.x / 2)
			{
				tf(player).pos.x = windowSize.x / 2 - tf(player).scale.x / 2;
				rb(player).vel.x *= (-1 + dampFactor);
			}
			else if (pBox.left < -windowSize.x / 2)
			{
				tf(player).pos.x = tf(player).scale.x / 2 - windowSize.x / 2;
				rb(player).vel.x *= (-1 + dampFactor);
			}
		}
	}


	// Obstacles
	{
		std::vector<Entity> obstacles = Entities("Obstacle");
		for (Entity e : obstacles)
			if (tf(e).pos.y > windowSize.y / 2 + tf(player).pos.y)
				DeleteEntity(e);

		for (int i = Entities("Obstacle").size(); i < STARTING_OBSTACLE_COUNT + score / 1000; i++)
			SpawnObstacle();
	}


	// Powerups
	{
		std::vector<Entity> powerups;
		powerups.insert(powerups.end(), Entities("Shield").begin(), Entities("Shield").end());
		powerups.insert(powerups.end(), Entities("Down").begin(), Entities("Down").end());
		powerups.insert(powerups.end(), Entities("Double").begin(), Entities("Double").end());
		for (Entity e : powerups)
			if (tf(e).pos.y > windowSize.y / 2 + tf(player).pos.y)
				DeleteEntity(e);

		if (powerupSpawnTimer > 0 && powerups.size() == 0)
			powerupSpawnTimer -= DeltaTime();

		if (powerups.size() == 0 && powerupSpawnTimer <= 0)
		{
			powerupSpawnTimer = POWERUP_SPAWN_RATE;
			SpawnPowerup();
		}

		{
			if (activePowerups & (int)Powerup::DOWN)
			{
				rb(player).AddForce({ 0,-DOWN_FORCE });
				downDurationTimer -= DeltaTime();
			}
			if (downDurationTimer <= 0)
			{
				downDurationTimer = DOWN_DURATION;
				activePowerups -= (int)Powerup::DOWN;
				std::vector<Entity> obstacles = Entities("Obstacle");
				for (Entity e : obstacles)
					DeleteEntity(e);
			}

			if (activePowerups & (int)Powerup::DOUBLE)
				doubleDurationTimer -= DeltaTime();
			if (doubleDurationTimer <= 0)
			{
				doubleDurationTimer = DOUBLE_DURATION;
				activePowerups -= (int)Powerup::DOUBLE;
			}
		}
	}


	// HUD
	{
		std::vector<Entity> hud = Entities("HUD");
		for (Entity e : hud)
			tf(e).pos.y = windowSize.y / 2 - 50 + tf(camera).pos.y;

		if (activePowerups & (int)Powerup::SHIELD)
			tf(shieldHUD).scale = Vector2<float>{96,85} * 0.6;
		else
			tf(shieldHUD).scale = {0,0};
		
		if (activePowerups & (int)Powerup::DOWN)
			tf(downHUD).scale = Vector2<float>{96,85} * 0.6;
		else
			tf(downHUD).scale = {0,0};

		if (activePowerups & (int)Powerup::DOUBLE)
			tf(doubleHUD).scale = Vector2<float>{96,85} * 0.6;
		else
			tf(doubleHUD).scale = {0,0};


		tf(scoreHUD).scale = {64.f * txt(scoreHUD).text.size(), 64};
		tf(scoreHUD).pos.x = windowSize.x / 2 - tf(scoreHUD).scale.x / 2 - 32;
	}
}


void Game::Reset()
{
	std::vector<Entity> temp = Entities();
	for (Entity e : temp)
		DeleteEntity(e);

	score = 0;
	gameover = false;
	Start();
}

void Game::SpawnObstacle()
{
	Entity e = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE | ComponentFlag::RIGIDBODY | ComponentFlag::BOX_TRIGGER);
	tf(e).pos = {(float)RangeRNG(-windowSize.x / 2, windowSize.x / 2), (float)RangeRNG(-windowSize.y, -windowSize.y / 2) + tf(camera).pos.y};
	sp(e) = GetSprite("res\\sprites\\spike.png");
	tf(e).scale = {100, 50};
	rb(e).vel = {0,(float)RangeRNG(20,200)};
	bt(e).scale = {tf(e).scale.x * 0.7f, tf(e).scale.y * 0.4f};
	bt(e).pos.y = tf(e).scale.y / 3;

	SetType("Obstacle", e);
}


void Game::SpawnPowerup()
{
	Entity e = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE | ComponentFlag::CIRCLE_TRIGGER);
	tf(e).pos = {(float)RangeRNG(-windowSize.x / 2 + 100, windowSize.x / 2 - 100), (float)RangeRNG(-windowSize.y * 2, -windowSize.y) + tf(camera).pos.y};

	int r = RangeRNG(1, 3);
	switch (r)
	{
		case 1:
			sp(e) = GetSprite("res\\sprites\\shield.png");
			SetType("Shield", e);
			break;

		case 2:
			sp(e) = GetSprite("res\\sprites\\2.png");
			SetType("Double", e);
			break;

		case 3:
			sp(e) = GetSprite("res\\sprites\\down.png");
			SetType("Down", e);
			break;
	}

	tf(e).scale = {70, 70};
	ct(e).radius = tf(e).scale.x / 2;
}