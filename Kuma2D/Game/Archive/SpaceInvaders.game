#include "Game.h"




constexpr int STARTING_ALIEN_COUNT{5};
constexpr int ALIENS_PER_LEVEL{5};
constexpr int PLAYER_MOVE_FORCE{600};
constexpr int PLAYER_MAX_SPEED{120};
constexpr int ALIEN_SPEED_FACTOR{200};
constexpr float FIRE_RATE{0.5};

#define rb(e) (GetComponent<Rigidbody>(e)) 
#define tf(e) (GetComponent<Transform>(e))
#define sp(e) (GetComponent<Sprite>(e))

Entity player;
std::vector<Entity> aliens;
std::vector<Entity> bullets;
float fireCooldown = 0;
int level = 0;

void Game::Start()
{
	player = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE | ComponentFlag::RIGIDBODY | ComponentFlag::CIRCLE_COLLIDER);
	GetComponent<Sprite>(player).texture = GetTexture("res\\ship.png");
	GetComponent<Transform>(player).pos = {0, -windowSize.y * 1 / 3};
	GetComponent<Transform>(player).scale = {60, 35};
	GetComponent<Rigidbody>(player).friction = 120;
	GetComponent<CircleCollider>(player).radius = GetComponent<Transform>(player).scale.x / 2;

	for (int n = 0, i = 1, j = 1; n < ALIENS_PER_LEVEL * level + STARTING_ALIEN_COUNT; n++, i++)
	{
		Entity e = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE | ComponentFlag::RIGIDBODY);
		aliens.push_back(e);
		tf(e).scale = {30, 25};

		if (tf(e).scale.x * 1.5f * i > windowSize.x)
		{
			j++;
			i = 1;
		}

		tf(e).pos = {tf(e).scale.x * 1.5f * i - windowSize.x / 2, -tf(e).scale.y * 2 * j + windowSize.y / 2};
		GetComponent<Sprite>(e).texture = GetTexture("res\\alien.png");
		GetComponent<Rigidbody>(e).vel = {ALIEN_SPEED_FACTOR / (float)(ALIENS_PER_LEVEL * level + STARTING_ALIEN_COUNT), 0};
		rb(e).friction = 0;
	}

	for (int i = 1; i < level + 1; i++)
	{
		Entity e = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE);
		GetComponent<Transform>(e).scale = {10,10};
		GetComponent<Transform>(e).pos = {-windowSize.x / 2 + 2 * i * GetComponent<Transform>(e).scale.x, -windowSize.y / 2 + 2 * GetComponent<Transform>(e).scale.y};
		GetComponent<Sprite>(e).texture = GetTexture("res\\box.png");
	}
}



void Game::Update()
{
	Player();
	Bullets();
	Aliens();
	GameStateCheck();

	if (input.GetKeyDown(SDL_SCANCODE_R) || aliens.size() == 0)
	{
		level++;
		Reset();
	}
}



void Game::Player()
{
	if (input.GetKey(SDL_SCANCODE_A) || input.GetKey(SDL_SCANCODE_LEFT))
		rb(player).acc.x -= (PLAYER_MOVE_FORCE / rb(player).mass);
	if (input.GetKey(SDL_SCANCODE_D) || input.GetKey(SDL_SCANCODE_RIGHT))
		rb(player).acc.x += (PLAYER_MOVE_FORCE / rb(player).mass);

	if (Magnitude(rb(player).vel) > PLAYER_MAX_SPEED)
		rb(player).acc.x = 0;
}

void Game::Aliens()
{
	bool leftHit = false, rightHit = false;
	for (Entity e : aliens)
	{
		BoundingBox box = GetComponent<Transform>(e);

		if (box.left <= -windowSize.x / 2)
		{
			leftHit = true;
			break;
		}
		else if (box.right >= windowSize.x / 2)
		{
			rightHit = true;
			break;
		}
	}


	if (leftHit)
	{
		for (Entity e : aliens)
		{
			rb(e).vel.x = static_cast<float>(ALIEN_SPEED_FACTOR) / aliens.size();
			tf(e).pos.y -= 40;
			tf(e).pos.x += 10;
		}
	}
	else if (rightHit)
	{
		for (Entity e : aliens)
		{
			rb(e).vel.x = 0 - static_cast<float>(ALIEN_SPEED_FACTOR) / aliens.size();
			tf(e).pos.y -= 40;
			tf(e).pos.x -= 10;
		}
	}
}

void Game::Bullets()
{
	fireCooldown += DeltaTime();

	if (input.GetKeyDown(SDL_SCANCODE_SPACE) && fireCooldown >= FIRE_RATE)
	{
		fireCooldown = 0;
		Entity e = CreateEntity(ComponentFlag::TRANSFORM | ComponentFlag::SPRITE | ComponentFlag::RIGIDBODY);
		bullets.push_back(e);
		tf(e).pos = tf(player).pos;
		tf(e).scale = {10, 10};
		tf(e).pos.y += 30;
		sp(e).texture = GetTexture("res\\ball.png");
		rb(e).vel.y = 200;
		rb(e).friction = 0;
	}

	auto it = bullets.begin();
	while (it != bullets.end())
	{
		if (tf(*it).pos.y > windowSize.y / 2)
		{
			DeleteEntity(*it);
			it = bullets.erase(it);
		}
		else
			it++;
	}
}


void Game::GameStateCheck()
{
	BoundingBox pBox = tf(player);
	std::vector<Entity> deleteEntities;

	for (Entity alien : aliens)
	{
		BoundingBox aBox = tf(alien);
		if (Overlapping(aBox, pBox))
		{
			level = 0;
			Reset();
			return;
		}

		for (Entity bullet : bullets)
		{
			BoundingBox bBox = tf(bullet);
			if (Overlapping(aBox, bBox))
			{
				deleteEntities.push_back(alien);
				deleteEntities.push_back(bullet);

				for (Entity a : aliens)
				{
					rb(a).vel.x *= aliens.size();
					rb(a).vel.x /= aliens.size() - 1;
				}
			}
		}
	}


	aliens.erase(std::remove_if(aliens.begin(), aliens.end(),
		[&](const auto& x) { return std::find(deleteEntities.begin(), deleteEntities.end(), x) != deleteEntities.end(); }),
		aliens.end());

	bullets.erase(std::remove_if(bullets.begin(), bullets.end(),
		[&](const auto& x) { return std::find(deleteEntities.begin(), deleteEntities.end(), x) != deleteEntities.end(); }),
		bullets.end());

	for (Entity e : deleteEntities)
		DeleteEntity(e);

	deleteEntities.clear();
}


void Game::Reset()
{
	std::vector<Entity> entities = GetEntities();
	for (Entity e : entities)
		DeleteEntity(e);

	aliens.clear();
	bullets.clear();

	Start();
}